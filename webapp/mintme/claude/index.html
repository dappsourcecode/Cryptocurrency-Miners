<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Webchain Miner Dashboard</title>
    <style>
        body { font-family: 'Consolas', 'Monaco', monospace; background: #0d0d0d; color: #0f0; padding: 20px; }
        h1 { margin-bottom: 5px; color: #fff; }
        .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .card { background: #1a1a1a; padding: 15px; border: 1px solid #333; border-radius: 5px; }
        .card label { display: block; color: #888; font-size: 0.8em; margin-bottom: 5px; }
        .card span { font-size: 1.2em; font-weight: bold; color: #eee; }
        .success { color: #0f0 !important; }
        .danger { color: #f44 !important; }
        .info { color: #0ff !important; }
        button { background: #004400; color: #0f0; border: 1px solid #0f0; padding: 10px 20px; cursor: pointer; font-family: inherit; font-size: 1em; }
        button:hover { background: #006600; }
        #log { border: 1px solid #333; height: 300px; overflow-y: scroll; background: #000; padding: 10px; font-size: 0.9em; }
        #log div { margin-bottom: 3px; }
        .status-connecting { color: #ff0; }
        .status-mining { color: #0f0; }
        .status-disconnected { color: #f44; }
    </style>
</head>
<body>
    <h1>Webchain Miner ‚õèÔ∏è</h1>
    <p style="color: #666; margin-top:0;">Protocol: MintMe | Mode: 64-bit Nonce</p>

    <div class="dashboard">
        <div class="card">
            <label>HASHRATE</label>
            <span id="hashrate" class="info">0.00</span> H/s
        </div>
        <div class="card">
            <label>DIFFICULTY</label>
            <span id="difficulty">Waiting...</span>
        </div>
        <div class="card">
            <label>SHARES (ACC / REJ)</label>
            <span id="acc" class="success">0</span> / <span id="rej" class="danger">0</span>
        </div>
        <div class="card">
            <label>CURRENT JOB ID</label>
            <span id="jobId" style="font-size: 0.9em;">None</span>
        </div>
        <div class="card">
            <label>ALGORITHM</label>
            <span id="algorithm" style="font-size: 0.9em; color: #0ff;">Unknown</span>
        </div>
        <div class="card">
            <label>STATUS</label>
            <span id="status" class="status-disconnected">Disconnected</span>
        </div>
    </div>

    <button id="btnConnect" onclick="toggleConnect()">Start Mining</button>
    <br><br>
    <div id="log"></div>

    <script>
        const PROXY_URL = "ws://127.0.0.1:8888";
        const WALLET = "0xa733c9545a3476de410e7704d8be586d59db9c6d";

        let socket = null;
        let worker = null;
        let batchHashes = 0;
        let accepted = 0;
        let rejected = 0;
        let lastRateUpdate = Date.now();
        let isConnected = false;
        let currentJobBlob = "";

        function log(msg, color = '#888') {
            const el = document.getElementById('log');
            const d = document.createElement('div');
            d.style.color = color;
            d.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            el.prepend(d);
            el.scrollTop = 0;
        }

        function toggleConnect() {
            if (isConnected) {
                disconnect();
            } else {
                connect();
            }
        }

        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
            if (worker) {
                worker.terminate();
                worker = null;
            }
            isConnected = false;
            document.getElementById('btnConnect').innerText = "Start Mining";
            document.getElementById('status').innerText = "Stopped";
            document.getElementById('status').className = "status-disconnected";
            log("Mining stopped", "#f44");
        }

        function initWorker() {
            if (worker) return;
            
            worker = new Worker('worker.js');
            worker.onmessage = function(e) {
                if (e.data.type === 'ready') {
                    log("WASM worker ready", "#0ff");
                } else if (e.data.type === 'stats') {
                    batchHashes += e.data.hashes;
                    updateHashrate();
                } else if (e.data.type === 'share') {
                    log(`üíé Share Found! Nonce: ${e.data.nonce}`, '#0ff');
                    submitShare(e.data.jobId, e.data.nonce, e.data.result, e.data.blob);
                }
            };
            
            worker.onerror = function(e) {
                log(`Worker error: ${e.message}`, '#f44');
            };
        }

        function connect() {
            initWorker();
            
            log("Connecting to Proxy...", "#fff");
            socket = new WebSocket(PROXY_URL);

            socket.onopen = () => {
                isConnected = true;
                document.getElementById('btnConnect').innerText = "Stop Mining";
                document.getElementById('status').innerText = "Connected";
                document.getElementById('status').className = "status-connecting";
                
                log("Logging in...", "#fff");
                socket.send(JSON.stringify({
                    id: 1,
                    method: "login",
                    params: { 
                        login: WALLET, 
                        pass: "x", 
                        agent: "webchain-miner/0.1" 
                    }
                }));
            };

            socket.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    
                    // Debug: log full message for troubleshooting
                    console.log("Pool message:", msg);

                    // 1. Handle Login Response
                    if (msg.id === 1) {
                        if (msg.result && msg.result.status === 'OK') {
                            log("‚úÖ Login Accepted", "#0f0");
                            document.getElementById('status').innerText = "Mining";
                            document.getElementById('status').className = "status-mining";
                            
                            if (msg.result.job) {
                                processJob(msg.result.job);
                            }
                        } else if (msg.error) {
                            log(`‚ùå Login Failed: ${JSON.stringify(msg.error)}`, "#f44");
                            disconnect();
                        }
                    }
                    
                    // 2. Handle New Job Push
                    else if (msg.method === 'job') {
                        processJob(msg.params);
                    }
                    
                    // 3. Handle Share Result - THIS IS CRITICAL
                    else if (msg.id === 4 || msg.id === "4") {
                        console.log("Share response:", msg);
                        
                        // Check for explicit result object with status
                        if (msg.result && typeof msg.result === 'object' && msg.result.status === 'OK') {
                            accepted++;
                            document.getElementById('acc').innerText = accepted;
                            log("üí∞ Share Accepted!", "#0f0");
                        }
                        // Check for boolean true result
                        else if (msg.result === true) {
                            accepted++;
                            document.getElementById('acc').innerText = accepted;
                            log("üí∞ Share Accepted!", "#0f0");
                        }
                        // Check for error
                        else if (msg.error) {
                            rejected++;
                            document.getElementById('rej').innerText = rejected;
                            const errorMsg = msg.error.message || JSON.stringify(msg.error);
                            log(`‚ö†Ô∏è Share Error: ${errorMsg}`, "#ff9900");
                        }
                        // Result is false or something else
                        else {
                            rejected++;
                            document.getElementById('rej').innerText = rejected;
                            log(`‚ö†Ô∏è Share Rejected: ${JSON.stringify(msg.result || 'false')}`, "#ff9900");
                        }
                    }
                    
                    // 4. Handle other responses
                    else if (msg.id && msg.result !== undefined) {
                        console.log("Generic response:", msg);
                    }
                    
                } catch (err) {
                    log(`Failed to parse message: ${err}`, "#f44");
                }
            };
            
            socket.onerror = (error) => {
                log(`Socket error: ${error}`, "#f44");
            };
            
            socket.onclose = () => {
                isConnected = false;
                document.getElementById('status').innerText = "Disconnected";
                document.getElementById('status').className = "status-disconnected";
                document.getElementById('btnConnect').innerText = "Start Mining";
                log("Socket Disconnected", "#f44");
            };
        }

        function processJob(jobObj) {
            if (!jobObj) return;
            
            const shortId = jobObj.job_id ? jobObj.job_id.substring(0, 8) + "..." : "Unknown";
            document.getElementById('jobId').innerText = shortId;
            
            // Store blob for submission
            if (jobObj.blob) {
                currentJobBlob = jobObj.blob;
            }
            
            // Update algorithm display
            if (jobObj.algo) {
                document.getElementById('algorithm').innerText = jobObj.algo;
                document.getElementById('algorithm').style.color = 
                    jobObj.algo.includes("lyra2v2") ? "#0ff" : 
                    jobObj.algo.includes("lyra2") ? "#0f0" : "#888";
            }
            
            // Calculate and display difficulty
            if (jobObj.target) {
                const diff = calculateDifficulty(jobObj.target);
                document.getElementById('difficulty').innerText = diff.toLocaleString();
            }
            
            log(`üì¶ New Job: ${shortId} (${jobObj.algo || "unknown"})`, "#888");
            
            // Send job to worker
            if (worker) {
                worker.postMessage({ command: 'job', data: jobObj });
                worker.postMessage({ command: 'start' });
            }
        }

        function submitShare(jobId, nonce, result, blob) {
            console.log(`Submitting share:`, {
                jobId: jobId,
                nonce: nonce,
                resultPreview: result.substring(0, 16) + "..."
            });
            
            // CRITICAL FIX: Pool expects params as OBJECT, not ARRAY
            // From stratum.go line 113: var params map[string]string
            const submitMessage = {
                id: 4,
                method: "submit",
                params: {
                    job_id: jobId,      // The job ID
                    nonce: nonce,       // 16 hex chars (8 bytes, no 0x prefix)
                    result: result      // 64 hex chars (32 bytes, no 0x prefix)
                }
            };
            
            console.log("Sending submit message:", JSON.stringify(submitMessage));
            socket.send(JSON.stringify(submitMessage));
        }

        function updateHashrate() {
            const now = Date.now();
            if (now - lastRateUpdate >= 1000) {
                const elapsedSeconds = (now - lastRateUpdate) / 1000;
                const hashRate = (batchHashes / elapsedSeconds).toFixed(2);
                document.getElementById('hashrate').innerText = hashRate;
                batchHashes = 0;
                lastRateUpdate = now;
            }
        }

        function calculateDifficulty(targetHex) {
            const max = 0xFFFFFFFFFFFFFFFFn;
            
            let cleanHex = targetHex.startsWith("0x") ? targetHex.slice(2) : targetHex;
            
            let beHex = "";
            for (let i = cleanHex.length - 2; i >= 0; i -= 2) {
                beHex += cleanHex.substr(i, 2);
            }
            
            const targetVal = BigInt("0x" + beHex);
            if (targetVal === 0n) return 0;
            
            return Number(max / targetVal);
        }

        window.addEventListener('beforeunload', function() {
            disconnect();
        });
    </script>
</body>
</html>